# 查找元素
![查找元素图片](picture/skiplist_search.png)
从当前最大层数开始找，如果查找的键比`cur`的下一个节点的键值大,cur就往后移动
找到大于等于`key`的第一个节点，如果那个节点等于`key`，就说明找到了，否则就没有该`key`。
# 插入元素
如果只把多个节点(很多很多)插入到最后一层中，然后不对上层的索引进行更新的话，那么再查找插入的节点过程中，在最后一层查找元素的过程就会退化成单链表查找的情况。
解决方法：在插入的最后一层每，两个节点提取一个节点给上一层。
怎么动态更新:
> 概率算法：
> + 每一层的节点，被提取到上一层的概率是1 / 2;
> + 原始链表提取到一级索引的概率是1 / 2。
> + 原始链表提取到二级索引的概率是1 / 4。
> + 原始链表提取到三层索引的概率是1 / 8。
```c++
    /*
        1/2的概率返回1。
        1/4的概率返回2。
        1/8的概率返回3。
        ....
    */
    int k = 1;
    while (rand() % 2) {
        k++;
    }
    k = (k < _max_level) ? k : _max_level;
```
![插入元素图片](picture/skiplist_search.png)

|  层数    | update数组值 |
| ---- | ---- |
| 4 | update[4] = 1; |
| 3 | update[3] = 10; |
| 2 | update[2] = 30; |
| 1 | update[1] = 30; |
| 0 | update[0] = 40; |
插入的关键代码:
```c++
for (int i = 0; i <= random_level; i++) {
    inserted_node->forward[i] = update[i]->forward[i];
    update[i]->forward[i] = inserted_node;
}
```
这里从图中可以看出random_level是3。
插入的点是50,将50插入到每一层对应的位置上。
**单层插入：**
```cpp
50->forward[0] = update[0]->forward[0]; //将50插入到第零层上
update[0]->forward[0] = 50;
```




 